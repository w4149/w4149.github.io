<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>智能对话系统</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style type="text/tailwindcss">
        @layer utilities {
            /* 滚动条样式优化 */
            .scrollable-area {
                scrollbar-width: thin;
            }
            .scrollable-area::-webkit-scrollbar {
                width: 6px;
            }
            .scrollable-area::-webkit-scrollbar-thumb {
                background-color: rgba(0,0,0,0.2);
                border-radius: 3px;
            }
            
            /* 加载状态样式 */
            .loading {
                color: #6B7280;
                font-style: italic;
            }
            
            /* 消息头像样式 */
            .message-avatar {
                width: 36px;
                height: 36px;
                border-radius: 50%;
                flex-shrink: 0;
            }
            
            /* 左侧面板布局 */
            .left-panel {
                width: 320px;
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }
            
            /* 一寸照比例头像容器 (3:4) */
            .id-photo-container {
                flex: 3;
                min-height: 240px;
                background-color: #f0f2f5;
                overflow: hidden;
                border-radius: 0.75rem;
            }
            
            /* 矩形头像样式 */
            .rect-avatar {
                width: 100%;
                height: 100%;
                object-fit: cover;
                display: block;
            }
            
            /* 输入框区域样式 */
            .input-panel {
                flex: 2;
                min-height: 180px;
            }

            /* 恐龙游戏样式 */
            .dino-game-container {
                margin-top: 1rem;
                border: 1px solid #e0e0e0;
                border-radius: 0.5rem;
                overflow: hidden;
                background-color: #fafafa;
                cursor: pointer; /* 显示点击指针 */
            }
            .game-info {
                padding: 0.5rem 1rem;
                background-color: #f0f0f0;
                display: flex;
                justify-content: flex-end;
                font-size: 0.875rem;
            }
            #gameCanvas {
                width: 100%;
                height: 150px;
                background-color: #ffffff;
            }
            
            /* 全黑页面样式 */
            .black-screen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: black;
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
                cursor: pointer;
            }
            
            /* 打字机效果容器 */
            .typewriter-container {
                font-size: 2rem;
                color: white;
                position: relative;
            }
            
            /* 光标样式 */
            .typewriter-cursor {
                display: inline-block;
                width: 2px;
                height: 2.2rem;
                background-color: white;
                margin-left: 4px;
                animation: blink 1s infinite;
            }
            
            @keyframes blink {
                0%, 49% { opacity: 1; }
                50%, 100% { opacity: 0; }
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-6">
    <div class="container mx-auto max-w-6xl">
        <!-- 主容器：左右布局 -->
        <div class="flex flex-col md:flex-row gap-6 h-[600px]">
            <!-- 左侧区域：头像 + 输入框 -->
            <div class="left-panel">
                <!-- 左侧上部：一寸照比例头像 -->
                <div class="id-photo-container shadow-md">
                    <img id="main-avatar" 
                         src="https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageROBOTPIXEL.png" 
                         alt="智能助手头像" 
                         class="rect-avatar"
                         onerror="this.src='https://picsum.photos/seed/robot/400/533'">
                </div>

                <!-- 左侧下部：输入框区域 -->
                <div class="input-panel bg-white rounded-xl shadow-md p-5 flex flex-col">
                    <h3 class="text-lg font-semibold text-gray-800 mb-3">输入消息</h3>
                    <textarea id="input-area" 
                              class="flex-1 w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition-all resize-none" 
                              placeholder="请输入您的问题..."></textarea>
                </div>
            </div>

            <!-- 右侧区域：对话记录 -->
            <div class="flex-1 bg-white rounded-xl shadow-md p-5 flex flex-col">
                <h3 class="text-lg font-semibold text-gray-800 mb-3">对话记录</h3>
                <div id="dialog-container" class="scrollable-area flex-1 overflow-y-auto p-2 space-y-4">
                    <div class="text-gray-400 text-center py-8">
                        开始您的对话吧
                    </div>
                </div>
            </div>
        </div>

        <!-- 底部恐龙游戏区域 -->
        <div class="dino-game-container mt-6">
            <div class="game-info">
                <span id="score">0</span>
            </div>
            <canvas id="gameCanvas"></canvas>
        </div>
    </div>

    <script>
        // ==============================================
        // 聊天功能相关代码
        // ==============================================
        
        // 定义两组头像资源
        const avatarSets = {

            set1: {
                text: '请回答下面问题，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageROBOTPIXEL.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageROBOTPIXEL.png'
            },
            set2: {
                text: '请回答下面问题，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageWHITEWOMANPIXEL.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageWHITEWOMANPIXEL.png'
            },
            set3: {
                text: '请回答下面问题，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageBLACKMANPIXEL.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageBLACKMANPIXEL.png'
            },
            set4: {
                text: '请以严谨理性的语言方式回答下面问题，但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageROBOT.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageROBOT_Thinking.png'
            },
            set5: {
                text: '请以白人女性的语言方式回答下面问题（请用中文回答），但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageWHITEWOMAN.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageWHITEWOMAN.png'
            },
            set6: {
                text: '请以黑人男性的语言方式回答下面问题（请用中文回答），但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',

                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageBLACKMAN.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageBLACKMAN.png'
            },
            set7: {
                text: '请以温柔助手的语言方式回答下面问题，但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageDOUBAO.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageDOUBAO_Thinking.png'
            },
            set8: {
                text: '请以积极乐观青年的语言方式回答下面问题，但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageGROK.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageGROK_Thinking.png'
            },
            set9: {
                text: '请以对科技有一定信心的技术人士的语言方式回答下面问题，但不要让人很容易就判断出你的身份，直接说一段文字，不要任何其他东西（比如表情符号、对自己身份的介绍、动作神情的描述）：',
                normal: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageMUSK.png',
                thinking: 'https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/ImageMUSK_Thinking.png'
            }
        };

        // 用户头像（固定）
        const userAvatar = 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48Y2lyY2xlIGN4PSIxOCIgY3k9IjE4IiByPSIxOCIgc3Ryb2tlPSIjMDAwIiBzdHJva2Utd2lkdGg9IjEiLz48L3N2Zz4=';
        
        // 当前使用的头像组（动态切换）
        let currentAvatarSet = avatarSets.set1;

        // 对话历史数组，用于保存上下文
        let conversationHistory = [];
        
        // 提问计数器
        let questionCounter = 0;

        // DOM元素引用
        const inputArea = document.getElementById('input-area');
        const dialogContainer = document.getElementById('dialog-container');
        const mainAvatar = document.getElementById('main-avatar');

        // 初始化事件监听
        function initEventListeners() {
            // 回车键发送消息（Shift+Enter换行）
            inputArea.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessageFromInput();
                }
            });
        }

        // 从输入框发送消息
        function sendMessageFromInput() {
            const text = inputArea.value.trim();
            if (text) {
                sendMessage(text);
                inputArea.value = '';
            }
        }

        // 发送消息并处理流程
        async function sendMessage(text) {
            // 提问计数器加1
            questionCounter++;
            
            // 根据提问次数选择头像组
            if (questionCounter === 1) {
                currentAvatarSet = avatarSets.set1;
            } else if (questionCounter === 2) {
                currentAvatarSet = avatarSets.set1;
            } else if (questionCounter === 3) {
                currentAvatarSet = avatarSets.set1;
            } else if (questionCounter === 4) {
                currentAvatarSet = avatarSets.set1;
            } else if (questionCounter === 5) {
                currentAvatarSet = avatarSets.set2;
            } else if (questionCounter === 6) {
                currentAvatarSet = avatarSets.set2;
            } else if (questionCounter === 7) {
                currentAvatarSet = avatarSets.set3;
            } else if (questionCounter === 8) {
                currentAvatarSet = avatarSets.set3;
            } else if (questionCounter === 9) {
                currentAvatarSet = avatarSets.set4;
            } else if (questionCounter === 10) {
                currentAvatarSet = avatarSets.set5;
            } else if (questionCounter === 11) { 
                currentAvatarSet = avatarSets.set6;
            } else if (questionCounter === 12) {
                currentAvatarSet = avatarSets.set7;
            } else if (questionCounter === 13) {
                currentAvatarSet = avatarSets.set8;
            } else {
                currentAvatarSet = avatarSets.set9;
            }









            
            // 在输入问题前添加限定
            wholeText = currentAvatarSet.text + text;
            // 添加用户消息到对话记录
            addToDialog('user', text);
            
            // 切换到思考状态
            setThinkingState(true);
            
            // 添加"正在思考"提示
            const loadingId = `loading-${Date.now()}`;
            addToDialog('ai', '正在思考...', false, loadingId);
            
            try {
                // 检查消息是否包含"需要多久"
                if (text.includes("需要多久")) {
                    // 不调用API，保持思考状态，直到下一次输入
                    // 不执行任何移除loading元素或设置thinking state为false的操作
                    return;
                }
                // 检查消息是否同时包含"单身"、"小狗"、"仪式"
                else if (text.includes("单身") && text.includes("小狗") && text.includes("仪式")) {
                    // 保持"正在思考"状态5秒后再显示回复
                    setTimeout(() => {
                        removeLoadingItem(loadingId);
                        addToDialog('ai', '是否开始生成报告？');
                        setThinkingState(false);
                    }, 3000);
                    // 不调用API，直接返回，让延迟函数执行
                    return;
                }
                // 检查消息是否包含"丝巾"
                else if (text.includes("丝巾")) {

                    // 假装处理，不调用API
                    await simulateReportGeneration(loadingId);
                } else {
                    // 检查消息是否包含"单人床"
                    let apiText = wholeText;
                    if (text.includes("单人床")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到“极简主义”这个词。）";
                    } else if (text.includes("长发") && text.includes("赤脚")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到“创意从业者”和“艺术家”这两个词。）";
                    } else if (text.includes("艺术家")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到：疲惫感还可能因为她是一个上班族，在业余时间做一些艺术创作。）";
                    } else if (text.includes("上班族") || text.includes("一本书") || text.includes("工作消息")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到：需要提供更多的信息。）";
                    } else if (text.includes("田野方法")) {
                        apiText = wholeText + "（正常输出回复，但是要首先提到：技术带来的帮助。）";
                    } else if (text.includes("宠物")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到：宠物的陪伴提供安全感，人与小动物更容易建立亲密。）";
                    } else if (text.includes("创作母题")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到：心理机制。）";
                    } else if (text.includes("出门")) {
                        apiText = wholeText + "（正常输出回复，但是要自然合理地提到：文艺演出。）";
                    } 

                    
                    // 正常调用API获取回复
                    const response = await callAssistantAPI(apiText);
                    
                    // 保存对话历史（用户消息和AI回复）
                    conversationHistory.push({ role: "user", content: wholeText });
                    conversationHistory.push({ role: "assistant", content: response });
                    
                    // 显示回复并恢复正常状态
                    removeLoadingItem(loadingId);
                    addToDialog('ai', response);
                    setThinkingState(false);
                }
            } catch (error) {
                // 处理错误
                removeLoadingItem(loadingId);
                addToDialog('ai', `获取回复失败：${error.message}`, true);
                setThinkingState(false);
            }
        }
        
        // 模拟报告生成过程
        async function simulateReportGeneration(loadingId) {
            // 首先将"正在思考..."替换为"生成中..."
            await new Promise(resolve => setTimeout(resolve, 1000));
            removeLoadingItem(loadingId);
            
            const generatingId = `generating-${Date.now()}`;
            addToDialog('ai', '最终报告生成中...', false, generatingId);
            
            // 20秒后创建全黑页面
            await new Promise(resolve => setTimeout(resolve, 19000));
            
            // 移除生成中提示
            removeLoadingItem(generatingId);
            setThinkingState(false);
            
            // 创建全黑页面
            createBlackScreen();
        }
        
        // 创建全黑页面并显示打字效果
        function createBlackScreen() {
            const blackScreen = document.createElement('div');
            blackScreen.className = 'black-screen';
            
            const typewriterContainer = document.createElement('div');
            typewriterContainer.className = 'typewriter-container';
            
            const textElement = document.createElement('span');
            textElement.textContent = '';
            
            const cursorElement = document.createElement('span');
            cursorElement.className = 'typewriter-cursor';
            
            typewriterContainer.appendChild(textElement);
            typewriterContainer.appendChild(cursorElement);
            blackScreen.appendChild(typewriterContainer);
            
            document.body.appendChild(blackScreen);
            
            // 打字机效果
            const message = '报告已生成，点击屏幕查看';
            let index = 0;
            
            function type() {
                if (index < message.length) {
                    textElement.textContent += message.charAt(index);
                    index++;
                    setTimeout(type, 200); // 每个字符显示的间隔时间
                }
            }
            
            // 开始打字效果
            type();
            
            // 点击屏幕后显示对话内容乱序随机节选并组成人脸形状
            blackScreen.addEventListener('click', function() {
                // 清空屏幕内容
                blackScreen.innerHTML = '';
                blackScreen.style.display = 'flex';
                blackScreen.style.flexWrap = 'wrap';
                blackScreen.style.justifyContent = 'center';
                blackScreen.style.alignContent = 'center';
                blackScreen.style.padding = '20px';
                
                // 获取所有对话内容文本
                const allMessages = Array.from(dialogContainer.querySelectorAll('.dialog-item'))
                    .map(item => {
                        const messageContent = item.querySelector('.rounded-lg');
                        return messageContent ? messageContent.textContent : '';
                    })
                    .filter(text => text && text !== '正在思考...' && text !== '最终报告生成中...');
                
                // 如果没有对话内容，显示默认文本
                if (allMessages.length === 0) {
                    const textElement = document.createElement('div');
                    textElement.className = 'text-white text-xl m-2';
                    textElement.textContent = '报告已生成';
                    blackScreen.appendChild(textElement);
                    return;
                }
                
                // 生成更分散的文本布局，让文本覆盖整个屏幕
                const faceRadius = Math.min(window.innerWidth, window.innerHeight) * 0.6; // 大幅增加半径，让文本分布更广
                const centerX = window.innerWidth / 2;
                const centerY = window.innerHeight / 2;
                const totalTexts = Math.min(200, allMessages.length * 5); // 增加文本总数上限
                
                // 创建初始文本片段
                const initialTexts = Math.min(100, allMessages.length * 3); // 增加初始生成的文本数量
                
                // 函数：创建随机文本片段
                function createRandomTextFragment() {
                    const randomMessage = allMessages[Math.floor(Math.random() * allMessages.length)];
                    const fragmentLength = Math.min(30, Math.floor(Math.random() * 20) + 10); // 片段长度10-30字符
                    const maxStartIndex = Math.max(0, randomMessage.length - fragmentLength);
                    const startIndex = Math.floor(Math.random() * (maxStartIndex + 1));
                    return randomMessage.substring(startIndex, startIndex + fragmentLength);
                }
                
                // 函数：将文本片段放置在人脸形状的位置
                function placeTextFragment(fragment, delay = 0) {
                    // 使用随机极坐标计算位置，形成人脸形状
                    // 调整分布逻辑，让文本更均匀地分布在整个屏幕
                    let angle, distanceFactor;
                    const randomPoint = Math.random();
                    
                    // 减少对中心区域的偏好，增加四周的文本分布
                    angle = Math.random() * Math.PI * 2;
                    distanceFactor = 0.2 + Math.random() * 0.8; // 0.2-1.0的随机距离因子，覆盖更多屏幕区域
                    
                    const x = centerX + Math.cos(angle) * faceRadius * distanceFactor;
                    const y = centerY + Math.sin(angle) * faceRadius * distanceFactor;
                    
                    // 创建文本元素
                    const textElement = document.createElement('div');
                    textElement.className = 'text-white absolute';
                    textElement.style.left = `${x}px`;
                    textElement.style.top = `${y}px`;
                    textElement.style.transform = 'translate(-50%, -50%)';
                    // 调整字体大小，让文本分布更合理
                    textElement.style.fontSize = `${Math.max(8, Math.floor(Math.random() * 16) + 6)}px`;
                    textElement.style.rotate = `${Math.random() * 360}deg`;
                    // 设置中等透明度，让文本更清晰可见
                    textElement.style.color = `rgba(255, 255, 255, ${0.5 + Math.random() * 0.2})`;
                    textElement.style.zIndex = Math.floor(Math.random() * 100); // 随机堆叠层级，允许叠加
                    textElement.textContent = fragment;
                    
                    // 添加淡入动画效果
                    textElement.style.transition = 'opacity 0.5s ease';
                    textElement.style.opacity = '0';
                    blackScreen.appendChild(textElement);
                    
                    // 延迟显示，创造更自然的逐个出现效果
                    setTimeout(() => {
                        textElement.style.opacity = `${0.5 + Math.random() * 0.2}`;
                    }, delay);
                }
                
                // 大量增加初始生成的文本片段数量，让文本覆盖整个页面
                for (let i = 0; i < initialTexts * 8; i++) {
                    const fragment = createRandomTextFragment();
                    const showDelay = Math.random() * 2000; // 0-2秒的随机延迟
                    placeTextFragment(fragment, showDelay);
                }
                
                // 设置碎片文本由慢变快出现的效果
                let active = true;
                let currentInterval = 200; // 初始间隔200毫秒（较慢）
                const minInterval = 5;     // 最小间隔5毫秒（最快）
                const acceleration = 5;    // 每次减少的毫秒数
                
                // 创建背景过渡的遮罩层
                const bgTransitionMask = document.createElement('div');
                bgTransitionMask.style.position = 'absolute';
                bgTransitionMask.style.top = '0';
                bgTransitionMask.style.left = '0';
                bgTransitionMask.style.width = '100%';
                bgTransitionMask.style.height = '100%';
                bgTransitionMask.style.zIndex = '198'; // 在文本下方，图片上方
                bgTransitionMask.style.backgroundColor = 'white';
                bgTransitionMask.style.opacity = '0';
                bgTransitionMask.style.pointerEvents = 'none';
                blackScreen.appendChild(bgTransitionMask);
                
                // 背景逐渐变白的动画
                const bgTransitionDuration = 900000; // 120秒，与文字生成过程相同
                const bgTransitionStartTime = performance.now();
                
                function updateBackgroundTransition() {
                    const elapsed = performance.now() - bgTransitionStartTime;
                    const progress = Math.min(elapsed / bgTransitionDuration, 1);
                    
                    // 计算背景过渡的不透明度
                    const bgOpacity = progress;
                    bgTransitionMask.style.opacity = `${bgOpacity}`;
                    
                    if (progress < 1) {
                        requestAnimationFrame(updateBackgroundTransition);
                    }
                }
                
                // 启动背景过渡动画
                updateBackgroundTransition();
                
                function generateText() {
                    if (!active) return;
                    
                    const fragment = createRandomTextFragment();
                    placeTextFragment(fragment);
                    
                    // 逐渐加快生成速度
                    if (currentInterval > minInterval) {
                        currentInterval = Math.max(minInterval, currentInterval - acceleration);
                    }
                    
                    // 设置下一次生成的定时器
                    setTimeout(generateText, currentInterval);
                }
                
                // 启动生成过程
                generateText();
                
                // 900秒后停止生成新片段并启动粒子效果
                setTimeout(() => {
                    active = false;
                    
                    // 将背景完全变为白色
                    blackScreen.style.backgroundColor = 'white';
                    bgTransitionMask.style.opacity = '1';
                    
                    // 延迟启动粒子效果，确保背景完全变白后再开始
                    setTimeout(() => {
                        createParticleEffect();
                    }, 500);
                }, 900000);
                
                // 文本淡出和图片淡入效果函数
                function createParticleEffect() {
                    // 收集所有文本元素
                    const textElements = Array.from(blackScreen.querySelectorAll('.text-white'));
                    const closeHint = blackScreen.querySelector('.bottom-10');
                    
                    // 如果有关闭提示文本，先隐藏
                    if (closeHint) {
                        closeHint.style.display = 'none';
                    }
                    
                    // 创建图片显示元素
                    const imageDisplay = document.createElement('img');
                    imageDisplay.src = 'ascii_art.png';
                    imageDisplay.style.position = 'absolute';
                    imageDisplay.style.left = '50%';
                    imageDisplay.style.top = '50%';
                    imageDisplay.style.transform = 'translate(-50%, -50%)';
                    imageDisplay.style.maxWidth = '80%';
                    imageDisplay.style.maxHeight = '80%';
                    imageDisplay.style.opacity = '0';
                    imageDisplay.style.zIndex = '200';
                    // 添加黑白反转滤镜
                    imageDisplay.style.filter = 'invert(100%)';
                    // 初始亮度设为最低
                    imageDisplay.style.brightness = '0';
                    imageDisplay.style.transition = 'opacity 3s ease-in, brightness 3s ease-in';
                    
                    // 创建四周扩散变白的遮罩层
                    const fadeMask = document.createElement('div');
                    fadeMask.style.position = 'absolute';
                    fadeMask.style.top = '0';
                    fadeMask.style.left = '0';
                    fadeMask.style.width = '100%';
                    fadeMask.style.height = '100%';
                    fadeMask.style.zIndex = '199'; // 在图片下方
                    fadeMask.style.backgroundColor = 'white';
                    fadeMask.style.opacity = '0';
                    fadeMask.style.borderRadius = '0';
                    fadeMask.style.transition = 'none'; // 禁用CSS过渡，使用JS动画
                    
                    // 添加到屏幕
                    blackScreen.appendChild(fadeMask);
                    
                    // 添加加载失败的处理
                    imageDisplay.onerror = function() {
                            console.error('Failed to load ascii_art.png');
                        // 如果图片加载失败，显示提示文本
                        const fallbackText = document.createElement('div');
                        fallbackText.textContent = '处理完成';
                        fallbackText.style.position = 'absolute';
                        fallbackText.style.left = '50%';
                        fallbackText.style.top = '50%';
                        fallbackText.style.transform = 'translate(-50%, -50%)';
                        fallbackText.style.color = 'white';
                        fallbackText.style.fontSize = '24px';
                        fallbackText.style.opacity = '0';
                        fallbackText.style.zIndex = '200';
                        fallbackText.style.transition = 'opacity 2s ease-in';
                        blackScreen.appendChild(fallbackText);
                        
                        // 使用提示文本继续动画
                        animateWithElement(fallbackText);
                    };
                    
                    // 添加到屏幕
                    blackScreen.appendChild(imageDisplay);
                    
                    // 动画函数
                        function animateWithElement(displayElement) {
                            // 动画持续时间
                            const duration = 3000; // 3秒
                            const startTime = performance.now();
                            
                            function animate() {
                                const elapsed = performance.now() - startTime;
                                const progress = Math.min(elapsed / duration, 1);
                                
                                // 图片淡入并增加亮度
                                const imageOpacity = progress;
                                displayElement.style.opacity = `${imageOpacity}`;
                                
                                // 亮度从0增加到1
                                const brightness = progress;
                                displayElement.style.brightness = `${brightness}`;
                                
                                // 文本淡出
                                const textOpacity = 1 - progress;
                                textElements.forEach(element => {
                                    if (element !== closeHint) {
                                        element.style.opacity = `${textOpacity}`;
                                    }
                                });
                                
                                // 隐藏淡入遮罩
                                fadeMask.style.opacity = '0';
                                
                                if (progress < 1) {
                                    requestAnimationFrame(animate);
                                } else {
                                    // 动画完成后移除文本元素
                                    textElements.forEach(element => {
                                        if (element !== closeHint && element.parentNode === blackScreen) {
                                            blackScreen.removeChild(element);
                                        }
                                    });
                                }
                            }
                            
                            // 开始动画
                            requestAnimationFrame(animate);
                        
                        // 动画完成后设置关闭逻辑
                        setTimeout(() => {
                            // 恢复关闭提示
                            if (closeHint) {
                                closeHint.style.display = 'block';
                            }
                            
                            // 设置点击关闭
                            blackScreen.onclick = function() {
                                active = false;
                                document.body.removeChild(blackScreen);
                            };
                        }, 5000); // 动画完成后设置关闭逻辑
                    }
                    
                    // 如果图片已经加载完成（比如缓存），直接开始动画
                    if (imageDisplay.complete) {
                        animateWithElement(imageDisplay);
                    } else {
                        // 否则等待图片加载完成
                        imageDisplay.onload = function() {
                            animateWithElement(imageDisplay);
                        };
                    }
                }
                
                // 简化的函数，因为我们不再需要加载图片和生成目标点
                function loadImageAndGeneratePoints(imageUrl) {
                    return new Promise((resolve) => {
                        resolve([]); // 返回空数组，因为不再需要目标点
                    });
                }
                

            });
        }

        // 切换思考状态头像
        function setThinkingState(isThinking) {
            mainAvatar.src = isThinking ? currentAvatarSet.thinking : currentAvatarSet.normal;
            mainAvatar.onerror = () => {
                mainAvatar.src = 'https://picsum.photos/seed/robot/400/533';
            };
        }

        // 调用助手API
        async function callAssistantAPI(query) {
            // 替换为实际API密钥
            const API_KEY = "sk-807f33ba0ae34437bf69c195d5068570";
            const API_URL = "https://api.deepseek.com/chat/completions";
            
            // 创建包含上下文的完整消息数组
            const fullMessages = [...conversationHistory, { role: "user", content: query }];
            
            const requestData = {
                model: "deepseek-chat",
                messages: fullMessages,
                temperature: 0.7,
                max_tokens: 1024
            };
            
            const response = await fetch(API_URL, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${API_KEY}`
                },
                body: JSON.stringify(requestData)
            });
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `HTTP错误: ${response.status}`);
            }
            
            const data = await response.json();
            return data.choices?.[0]?.message?.content || "未获取到有效回复";
        }

        // 添加内容到对话记录
        function addToDialog(role, content, isError = false, id = null) {
            const dialogDiv = document.createElement('div');
            dialogDiv.className = `dialog-item flex gap-3 p-2 transition-all ${id || ''}`;
            
            // 确定头像和样式
            const roleClass = role === 'user' ? 'bg-blue-50 text-blue-700' : 'bg-green-50 text-gray-800';
            const avatarSrc = role === 'user' 
                ? userAvatar 
                : (content === '正在思考...' ? currentAvatarSet.thinking : currentAvatarSet.normal);
            
            dialogDiv.innerHTML = `
                <img src="${avatarSrc}" 
                     alt="${role === 'user' ? '用户' : '智能助手'}" 
                     class="message-avatar mt-1"
                     onerror="this.src='${role === 'user' ? userAvatar : 'https://picsum.photos/seed/robot/36/36'}'">
                <div class="flex-1 max-w-[85%]">
                    <div class="p-3 rounded-lg ${roleClass} break-words">${content}</div>
                </div>
            `;
            
            // 加载状态样式
            if (content === '正在思考...') {
                dialogDiv.classList.add('loading');
            }
            
            // 错误状态样式
            if (isError) {
                const messageEl = dialogDiv.querySelector('div.rounded-lg');
                messageEl.classList.remove('bg-green-50', 'text-gray-800');
                messageEl.classList.add('bg-red-50', 'text-red-600');
            }
            
            // 移除初始提示文本
            const initialPrompt = dialogContainer.querySelector('.text-gray-400');
            if (initialPrompt) {
                dialogContainer.removeChild(initialPrompt);
            }
            
            // 添加到对话容器并滚动到底部
            dialogContainer.appendChild(dialogDiv);
            dialogContainer.scrollTop = dialogContainer.scrollHeight;
        }

        // 移除加载提示
        function removeLoadingItem(id) {
            const loadingItem = document.querySelector(`.${id}`);
            if (loadingItem) {
                loadingItem.remove();
            }
        }

        // ==============================================
        // 恐龙跳跃游戏相关代码（仙人掌替换为图片）
        // ==============================================
        
        // 游戏状态枚举
        const GameState = {
            NOT_STARTED: 0,  // 未开始
            RUNNING: 1,      // 运行中
            OVER: 2          // 已结束
        };
        
        // 障碍物图片加载
        const obstacleImage = new Image();
        obstacleImage.src = "https://oiwjj-1325666589.cos.ap-beijing.myqcloud.com/theother_XUBINGstyle.png";
        let imageLoaded = false;
        
        // 图片加载完成事件
        obstacleImage.onload = function() {
            imageLoaded = true;
        };
        
        // 图片加载失败时使用默认样式
        obstacleImage.onerror = function() {
            console.log("障碍物图片加载失败，将使用默认样式");
            imageLoaded = false;
        };
        
        // 游戏变量
        let canvas, ctx;
        let dino = {
            x: 50,
            y: 0,
            width: 40,
            height: 40,
            velocityY: 0,
            jumping: false,
            gravity: 0.6,
            jumpStrength: -12
        };
        
        let obstacles = [];
        let score = 0;
        let gameSpeed = 5;
        let gameState = GameState.NOT_STARTED; // 初始状态为未开始
        let animationId;
        let obstacleTimer;
        let groundHeight = 10; // 地面高度

        // 初始化游戏
        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            
            // 设置canvas尺寸
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // 重置游戏状态
            resetGame();
            
            // 点击游戏区域开始游戏
            canvas.addEventListener('click', () => {
                if (gameState === GameState.NOT_STARTED || gameState === GameState.OVER) {
                    resetGame();
                    gameState = GameState.RUNNING;
                    obstacleTimer = setInterval(createObstacle, 1500);
                }
            });
            
            // 监听空格键跳跃（仅在游戏运行中有效）
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' && gameState === GameState.RUNNING) {
                    e.preventDefault();
                    if (!dino.jumping) {
                        dino.jumping = true;
                        dino.velocityY = dino.jumpStrength;
                    }
                }
            });
            
            // 开始游戏循环
            gameLoop();
        }

        // 重置游戏
        function resetGame() {
            // 重置恐龙状态（站在地面上）
            const groundY = canvas.height - groundHeight - dino.height;
            dino.y = groundY;
            dino.velocityY = 0;
            dino.jumping = false;
            
            // 清空障碍物
            obstacles = [];
            if (obstacleTimer) clearInterval(obstacleTimer);
            
            // 重置游戏状态
            score = 0;
            gameSpeed = 5;
            gameState = GameState.NOT_STARTED;
            document.getElementById('score').textContent = '0';
        }

        // 创建障碍物（保持原有尺寸）
        function createObstacle() {
            if (gameState !== GameState.RUNNING) return;
            
            // 保持原有仙人掌尺寸范围
            const minHeight = 30;
            const maxHeight = 60;
            const height = Math.random() * (maxHeight - minHeight) + minHeight;
            const width = 20; // 保持原有宽度
            
            // 计算障碍物Y坐标，使其立在地面上
            const obstacleY = canvas.height - groundHeight - height;
            
            obstacles.push({
                x: canvas.width,
                y: obstacleY,
                width: width,
                height: height
            });
        }

        // 更新游戏状态
        function update() {
            if (gameState !== GameState.RUNNING) return;
            
            // 更新分数
            score++;
            document.getElementById('score').textContent = score.toString();
            
            // 加速游戏
            if (score % 100 === 0) {
                gameSpeed += 0.2;
            }
            
            // 更新恐龙位置（重力和跳跃）
            dino.velocityY += dino.gravity;
            dino.y += dino.velocityY;
            
            // 地面碰撞检测
            const groundY = canvas.height - groundHeight - dino.height;
            if (dino.y >= groundY) {
                dino.y = groundY;
                dino.velocityY = 0;
                dino.jumping = false;
            }
            
            // 更新障碍物位置
            for (let i = 0; i < obstacles.length; i++) {
                obstacles[i].x -= gameSpeed;
                
                // 移除超出画布的障碍物
                if (obstacles[i].x + obstacles[i].width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                }
            }
            
            // 碰撞检测（保持不变，因为尺寸未变）
            checkCollision();
        }

        // 碰撞检测
        function checkCollision() {
            // 恐龙的碰撞边界
            const dinoLeft = dino.x;
            const dinoRight = dino.x + dino.width;
            const dinoTop = dino.y;
            const dinoBottom = dino.y + dino.height;
            
            for (let obstacle of obstacles) {
                // 障碍物的碰撞边界（保持原有尺寸）
                const obstacleLeft = obstacle.x;
                const obstacleRight = obstacle.x + obstacle.width;
                const obstacleTop = obstacle.y;
                const obstacleBottom = obstacle.y + obstacle.height;
                
                // 精确的碰撞检测
                if (dinoRight > obstacleLeft && 
                    dinoLeft < obstacleRight && 
                    dinoBottom > obstacleTop && 
                    dinoTop < obstacleBottom) {
                    gameState = GameState.OVER; // 游戏结束
                    clearInterval(obstacleTimer);
                    return;
                }
            }
        }

        // 绘制游戏
        function draw() {
            // 清空画布
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 绘制地面
            ctx.fillStyle = '#e0e0e0';
            const groundY = canvas.height - groundHeight;
            ctx.fillRect(0, groundY, canvas.width, groundHeight);
            
            // 绘制恐龙
            ctx.fillStyle = '#333';
            ctx.fillRect(dino.x, dino.y, dino.width, dino.height);
            
            // 绘制眼睛
            ctx.fillStyle = 'white';
            ctx.fillRect(dino.x + dino.width - 10, dino.y + 10, 5, 5);
            
            // 绘制障碍物（使用图片，保持原有尺寸）
            if (imageLoaded) {
                for (let obstacle of obstacles) {
                    // 绘制图片，调整图片尺寸以匹配原有仙人掌尺寸
                    ctx.drawImage(
                        obstacleImage, 
                        obstacle.x, 
                        obstacle.y, 
                        obstacle.width, 
                        obstacle.height
                    );
                }
            } else {
                // 图片未加载时使用默认绿色矩形
                ctx.fillStyle = '#4CAF50';
                for (let obstacle of obstacles) {
                    ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                }
            }
            
            // 游戏未开始时显示提示
            /*
            if (gameState === GameState.NOT_STARTED) {
                ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('点击开始游戏', canvas.width / 2, canvas.height / 2);
            }
            */
            // 游戏结束时显示提示
            /*
            else if (gameState === GameState.OVER) {
                ctx.fillStyle = 'rgba(150, 150, 150, 0.5)';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('the Other', canvas.width / 2, canvas.height / 2);
            }
            */
        }

        // 游戏主循环
        function gameLoop() {
            update();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }

        // 初始化应用
        function initApp() {
            initEventListeners();
            initGame();
            
            // 监听窗口大小变化，调整canvas尺寸
            window.addEventListener('resize', () => {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                // 重新计算恐龙和障碍物位置以适应新尺寸
                const groundY = canvas.height - groundHeight - dino.height;
                dino.y = groundY;
                
                obstacles.forEach(obstacle => {
                    obstacle.y = canvas.height - groundHeight - obstacle.height;
                });
            });
            
            // 更新初始消息，真实发送给deepseek但不显示在对话记录中
            const initialMessage = "我在做一个人物研究，接下来会对她进行观察，请你帮助我";
            
            // 提问计数器加1
            questionCounter++;
            
            // 选择头像组
            currentAvatarSet = avatarSets.set1;
            
            // 在输入问题前添加限定
            wholeText = currentAvatarSet.text + initialMessage;
            
            // 只添加预设的AI回复到对话记录
            addToDialog('ai', "好的，开始你的描述。");
            
            // 真实调用deepseek API并将消息存入上下文，但不显示在对话记录中
            async function initConversation() {
                try {
                    // 先保存初始用户消息到历史
                    conversationHistory.push({ role: "user", content: wholeText });
                    
                    // 调用API获取真实回复
                    const realResponse = await callAssistantAPI(initialMessage);
                    
                    // 将真实回复存入历史，但不显示在界面上
                    conversationHistory.push({ role: "assistant", content: realResponse });
                    
                    console.log('初始对话已保存到上下文，但未显示在界面');
                } catch (error) {
                    console.error('初始API调用失败，使用默认回复:', error);
                    // 如果调用失败，使用预设回复作为备选
                    conversationHistory.push({ role: "assistant", content: "好的，开始你的描述。" });
                }
            }
            
            // 启动初始对话API调用
            initConversation();
        }

        // 启动应用
        initApp();
    </script>
</body>
</html>
